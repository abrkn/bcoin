#!/usr/bin/env node

'use strict';

// https://www.blockchain.com/btc/tx/033e83e3204b0cc28724e147f6fd140529b2537249f9c61c9de9972750030000
// first coin ^^^^

// https://www.blockchain.com/btc/tx/4aa1defd46f10c27ff4d6c2565e1e0e611429cd673b0f7342f30820690030000
// second coin ^^^^

// https://www.blockchain.com/btc/tx/e1c9467a885a156e56a29d9c854e65674d581ad75611b02290454b4862060000
// third coin ^^^

const assert = require('assert');
const ChainDB = require('../lib/blockchain/chain');
const { createReadStream } = require('fs');
const Script = require('../lib/script/script');
const { decompressKey, COMPRESS_TYPES, EMPTY_BUFFER } = require('../lib/coins/compress');
const consensus = require('../lib/protocol/consensus');

// const node = new FullNode({
//   file: true,
//   argv: true,
//   env: true,
//   logFile: true,
//   logConsole: true,
//   logLevel: 'debug',
//   memory: false,
//   workers: true,
//   listen: true,
//   loader: require
// });

function decompressScript(script, br) {
  // Decompress the script.
  const kind = br.readU8();
  false && console.log('CASE', kind);

  switch (kind) {
    case 0: {
      const hash = br.readBytes(20, true);
      script.fromPubkeyhash(hash);
      break;
    }
    case 1: {
      const hash = br.readBytes(20, true);
      script.fromScripthash(hash);
      break;
    }
    case 2:
    case 3:
    case 4:
    case 5: {
      br.offset -= 1;
      const data = br.readBytes(33, true);
      // Decompress the key. If this fails,
      // we have database corruption!
      const key = decompressKey(data);
      script.fromPubkey(key);
      break;
    }
    default: {
      br.offset -= 1;
      const size = br.readVarInt() - COMPRESS_TYPES;
      if (size > consensus.MAX_SCRIPT_SIZE) {
        // This violates consensus rules.
        // We don't need to read it.
        script.fromNulldata(EMPTY_BUFFER);
        br.seek(size);
      } else {
        const data = br.readBytes(size);
        script.fromRaw(data);
      }
      break;
    }
  }

  return script;
}

function readVarint(data, off) {
  let value, size;

  // checkRead(off < data.length, off);

  switch (data[off]) {
    case 0xff:
      size = 9;
      // checkRead(off + size <= data.length, off);
      throw new Error('too big');
      // value = data.readU64LE(data, off + 1);
      // check(value > 0xffffffff, off, 'Non-canonical varint');
      break;
    case 0xfe:
      size = 5;
      // checkRead(off + size <= data.length, off);
      value = data.readUInt32LE(data, off + 1);
      // check(value > 0xffff, off, 'Non-canonical varint');
      break;
    case 0xfd:
      size = 3;
      // checkRead(off + size <= data.length, off);
      value = data.readUInt16LE(data, off + 1);
      // check(value >= 0xfd, off, 'Non-canonical varint');
      break;
    default:
      size = 1;
      value = data[off];
      break;
  }

  return { size, value };
}

function decompressValue(value) {
  if (value === 0)
    return 0;

  value--;

  let exp = value % 10;

  value = (value - exp) / 10;

  let n;
  if (exp < 9) {
    const last = value % 9;
    value = (value - last) / 9;
    n = value * 10 + last + 1;
  } else {
    n = value + 1;
  }

  while (exp > 0) {
    n *= 10;
    exp--;
  }

  return n;
}

function readUInt64LE(data, off) {
  const hi = data.readUInt32LE(data, off + 4);
  const lo = data.readUInt32LE(data, off);
  assert((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');
  return hi * 0x100000000 + lo;
}

process.on('unhandledRejection', (err, promise) => {
  throw err;
});

process.on('SIGINT', async () => {
});


const createReader = () => {
  const reader = {};

  reader.buffer = null;
  reader.offset = 0;

  reader.appendBuffer = (buffer) => {
    assert(buffer);

    if (reader.offset > 0) {
      reader.buffer = reader.buffer.slice(reader.offset);
      reader.offset = 0;
    }

    reader.buffer = reader.buffer ? Buffer.concat([reader.buffer, buffer]) : buffer;
  };

  reader.read32 = () => {
    const result = reader.buffer.readInt32LE(reader.offset);
    reader.offset += 4;
    return result;
  };

  reader.readU32 = () => {
    const result = reader.buffer.readUInt32LE(reader.offset);
    reader.offset += 4;
    return result;
  };

  // reader.readVarInt = () => {
  //   const { size, value } = readVarint(reader.buffer, reader.offset);
  //   reader.offset += size;
  //   return value;
  // };

  reader.readHeader = () => {
    return {
      versionRequired: reader.read32(),
      versionThatWrote: reader.read32(),
      coinCount: reader.read32(),
    };
  };

  reader.readU8 = () => {
    const value = reader.buffer[reader.offset];
    reader.offset += 1;
    return value;
  };

  reader.readBool = () => {
    const temp = reader.readU8();
    return (temp & 1) === 1;
  };

  reader.readBytes = (length) => {
    const result = reader.buffer.slice(reader.offset, reader.offset + length);
    reader.offset += length;
    return result;
  };

  reader.readVarInt = () => {
    let num = 0;
    let size = 0;
  
    for (;;) {
      // checkRead(off < data.length, off);
  
      const ch = reader.buffer[reader.offset++];
      size += 1;
  
      // Number.MAX_SAFE_INTEGER >>> 7
      assert(num <= 0x3fffffffffff - (ch & 0x7f), reader.offset, 'Number exceeds 2^53-1');
  
      // num = (num << 7) | (ch & 0x7f);
      num = (num * 0x80) + (ch & 0x7f);
  
      if ((ch & 0x80) === 0)
        break;
  
      assert(num !== Number.MAX_SAFE_INTEGER, reader.offset, 'Number exceeds 2^53-1');
      num += 1;
    }

    return num;
  };

  reader.readUInt64LE = () => {
    const result = readUInt64LE(reader.buffer, reader.offset);
    reader.offset += 8;
    return result;
  };

  reader.readLoadedCoin = () => {
    // uint32_t code = 0;
    // ::Unserialize(s, VARINT(code));
    // nHeight = code >> 1;
    // fCoinBase = code & 1;
    const code = reader.readVarInt();
    const height = code >> 1;
    assert(height > 0);
    const coinbase = code & 1;
    false && console.log({ code, height, coinbase });

    // ::Unserialize(s, fCriticalData); (bool, 1 byte)
    const criticalData = reader.readBool();
    false && console.log({ criticalData });

    // ::Unserialize(s, VARINT(nSidechain));
    const sidechainN = reader.readVarInt();
    false && console.log({ sidechainN });

    // ::Unserialize(s, VARINT(nPrevBlockRef));
    const prevBlockRef = reader.readVarInt();
    false && console.log({ prevBlockRef });

    // ::Unserialize(s, hashCritical);
    // 32 bytes
    const hashCritical = reader.readBytes(32);
    false && console.log({ hashCritical });

    // ::Unserialize(s, REF(CTxOutCompressor(out)));
    // uint64_t nVal = 0;
    // READWRITE(VARINT(nVal));
    const valueCompressed = reader.readVarInt();
    false && console.log({ valueCompressed });
    
    // txout.nValue = DecompressAmount(nVal); <-- uint64
    const value = decompressValue(valueCompressed);
    false && console.log({ value });

    // CScriptCompressor cscript(REF(txout.scriptPubKey));
    // READWRITE(cscript);
    const script = new Script();
    decompressScript(script, reader);
    false && console.log(script);

    const outpointHash = reader.readBytes(32);
    const outpointN = reader.readU32();
    false && console.log({ outpointHash, outpointN });
  };

  return reader;
};

(async () => {
  const options = {};
  const db = new ChainDB(options);
  await db.open();

  false && console.log(db);

  const stream = createReadStream(__dirname + '/../loaded_coins.dat', {
    highWaterMark: 1024 * 1024
  });

  const reader = createReader();

  let header;

  let coinIndex = 0;

  stream.on('data', (data) => {
    false && console.log('data len', data.length);
    reader.appendBuffer(data);

    if (!header) {
    header = reader.readHeader();
    false && console.log({ header });
    }

    while (reader.buffer.length - reader.offset > 1024 * 10) {
      false && console.log('- - - - - - - - - - - - - - - - - - - -');
      reader.readLoadedCoin();

      coinIndex++;

      if (coinIndex % 1e6 === 0) {
        console.log('Read', coinIndex / 1e6, 'M');
      }
    }
  });

  stream.on('end', (data) => {
    reader.appendBuffer(data);

    while (reader.buffer.length - reader.offset > 1024 * 10) {
      false && console.log('- - - - - - - - - - - - - - - - - - - -');
      reader.readLoadedCoin();

      coinIndex++;

      if (coinIndex % 100 === 0) {
        console.log({ coinIndex });
      }
    }
  });

  false && console.log('EOI');
})().catch((err) => {
  console.error(err.stack);
  process.exit(1);
});
